var data = {lines:[
{"lineNum":"    1","line":"# Copyright 2020 @q9f","class":"lineCov","hits":"1","order":"4","possible_hits":"1",},
{"lineNum":"    2","line":"#"},
{"lineNum":"    3","line":"# Licensed under the Apache License, Version 2.0 (the \"License\");"},
{"lineNum":"    4","line":"# you may not use this file except in compliance with the License."},
{"lineNum":"    5","line":"# You may obtain a copy of the License at"},
{"lineNum":"    6","line":"#"},
{"lineNum":"    7","line":"#     http://www.apache.org/licenses/LICENSE-2.0"},
{"lineNum":"    8","line":"#"},
{"lineNum":"    9","line":"# Unless required by applicable law or agreed to in writing, software"},
{"lineNum":"   10","line":"# distributed under the License is distributed on an \"AS IS\" BASIS,"},
{"lineNum":"   11","line":"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."},
{"lineNum":"   12","line":"# See the License for the specific language governing permissions and"},
{"lineNum":"   13","line":"# limitations under the License."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"# Exposes a set of utilities to ease the handling of different data types."},
{"lineNum":"   16","line":"# It comes in handy when building protocols further decoding RLP byte-streams."},
{"lineNum":"   17","line":"#"},
{"lineNum":"   18","line":"# ```"},
{"lineNum":"   19","line":"# decoded = Rlp.decode Bytes[197, 42, 131, 101, 116, 104]"},
{"lineNum":"   20","line":"# pp decoded"},
{"lineNum":"   21","line":"# # => [Bytes[42], Bytes[101, 116, 104]]"},
{"lineNum":"   22","line":"#"},
{"lineNum":"   23","line":"# protocol = [] of String | Int32 | BigInt"},
{"lineNum":"   24","line":"# protocol << Rlp::Util.bin_to_int decoded[0]"},
{"lineNum":"   25","line":"# protocol << Rlp::Util.bin_to_str decoded[1]"},
{"lineNum":"   26","line":"# pp protocol"},
{"lineNum":"   27","line":"# # => [42, \"eth\"]"},
{"lineNum":"   28","line":"# ```"},
{"lineNum":"   29","line":"module Rlp::Util"},
{"lineNum":"   30","line":"  # Converts binary `Bytes` to a `BigInt`."},
{"lineNum":"   31","line":"  #"},
{"lineNum":"   32","line":"  # Parameters:"},
{"lineNum":"   33","line":"  # * `b` (`Bytes`): the binary `Bytes` data to convert."},
{"lineNum":"   34","line":"  #"},
{"lineNum":"   35","line":"  # ```"},
{"lineNum":"   36","line":"  # Rlp::Util.bin_to_int Bytes[15, 66, 64]"},
{"lineNum":"   37","line":"  # # => 1000000"},
{"lineNum":"   38","line":"  # ```"},
{"lineNum":"   39","line":"  def self.bin_to_int(b : Bytes)","class":"lineCov","hits":"2","order":"90","possible_hits":"2",},
{"lineNum":"   40","line":"    BigInt.new b.hexstring, 16","class":"lineCov","hits":"1","order":"91","possible_hits":"1",},
{"lineNum":"   41","line":"  end"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"  # Overloads `bin_to_int` with arbitrary data types and raises if"},
{"lineNum":"   44","line":"  # input data is not binary."},
{"lineNum":"   45","line":"  #"},
{"lineNum":"   46","line":"  # NOTE: Raises in any case if `a` actually contains non-binary or nested data."},
{"lineNum":"   47","line":"  # Shouldn\'t be used if decoded `Rlp` data could contain nested data structures."},
{"lineNum":"   48","line":"  def self.bin_to_int(a)"},
{"lineNum":"   49","line":"    raise \"Cannot convert arbitrary data to numbers, please unpack first!\""},
{"lineNum":"   50","line":"  end"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"  # Converts binary `Bytes` to a hex-encoded `String`."},
{"lineNum":"   53","line":"  #"},
{"lineNum":"   54","line":"  # Parameters:"},
{"lineNum":"   55","line":"  # * `b` (`Bytes`): the binary `Bytes` data to convert."},
{"lineNum":"   56","line":"  #"},
{"lineNum":"   57","line":"  # ```"},
{"lineNum":"   58","line":"  # Rlp::Util.bin_to_hex Bytes[4, 200, 29]"},
{"lineNum":"   59","line":"  # # => \"04c81d\""},
{"lineNum":"   60","line":"  # ```"},
{"lineNum":"   61","line":"  def self.bin_to_hex(b : Bytes)","class":"lineCov","hits":"2","order":"101","possible_hits":"2",},
{"lineNum":"   62","line":"    h = b.hexstring","class":"lineCov","hits":"1","order":"102","possible_hits":"1",},
{"lineNum":"   63","line":"    return \"0#{h}\" if h.size.odd?","class":"lineCov","hits":"1","order":"103","possible_hits":"1",},
{"lineNum":"   64","line":"    h"},
{"lineNum":"   65","line":"  end"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"  # Converts binary `Bytes` to a `String` literal."},
{"lineNum":"   68","line":"  #"},
{"lineNum":"   69","line":"  # Parameters:"},
{"lineNum":"   70","line":"  # * `b` (`Bytes`): the binary `Bytes` data to convert."},
{"lineNum":"   71","line":"  #"},
{"lineNum":"   72","line":"  # ```"},
{"lineNum":"   73","line":"  # Rlp::Util.bin_to_str Bytes[97, 98, 99]"},
{"lineNum":"   74","line":"  # # => \"abc\""},
{"lineNum":"   75","line":"  # ```"},
{"lineNum":"   76","line":"  def self.bin_to_str(b : Bytes)","class":"lineCov","hits":"2","order":"104","possible_hits":"2",},
{"lineNum":"   77","line":"    String.new b","class":"lineCov","hits":"1","order":"105","possible_hits":"1",},
{"lineNum":"   78","line":"  end"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"  # Overloads `bin_to_str` with arbitrary data types and raises if"},
{"lineNum":"   81","line":"  # input data is not binary."},
{"lineNum":"   82","line":"  #"},
{"lineNum":"   83","line":"  # NOTE: Raises in any case if `a` actually contains non-binary or nested data."},
{"lineNum":"   84","line":"  # Shouldn\'t be used if decoded `Rlp` data could contain nested data structures."},
{"lineNum":"   85","line":"  def self.bin_to_str(a)"},
{"lineNum":"   86","line":"    raise \"Cannot convert arbitrary data to strings, please unpack first!\""},
{"lineNum":"   87","line":"  end"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"  # Converts integers to binary `Bytes`."},
{"lineNum":"   90","line":"  #"},
{"lineNum":"   91","line":"  # Parameters:"},
{"lineNum":"   92","line":"  # * `i` (`Int`): the integer to convert."},
{"lineNum":"   93","line":"  #"},
{"lineNum":"   94","line":"  # ```"},
{"lineNum":"   95","line":"  # Rlp::Util.int_to_bin 1_000_000"},
{"lineNum":"   96","line":"  # # => Bytes[15, 66, 64]"},
{"lineNum":"   97","line":"  # ```"},
{"lineNum":"   98","line":"  def self.int_to_bin(i : Int)","class":"linePartCov","hits":"5","order":"12","possible_hits":"6",},
{"lineNum":"   99","line":"    h = i.to_s 16","class":"linePartCov","hits":"5","order":"13","possible_hits":"6",},
{"lineNum":"  100","line":"    h = \"0#{h}\" if h.size.odd?","class":"linePartCov","hits":"5","order":"14","possible_hits":"6",},
{"lineNum":"  101","line":"    h.hexbytes","class":"linePartCov","hits":"5","order":"15","possible_hits":"6",},
{"lineNum":"  102","line":"  end"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"  # Converts integers to hex-encoded `String`s."},
{"lineNum":"  105","line":"  #"},
{"lineNum":"  106","line":"  # Parameters:"},
{"lineNum":"  107","line":"  # * `i` (`Int`): the integer to convert."},
{"lineNum":"  108","line":"  #"},
{"lineNum":"  109","line":"  # ```"},
{"lineNum":"  110","line":"  # Rlp::Util.int_to_hex 313_373"},
{"lineNum":"  111","line":"  # # => \"04c81d\""},
{"lineNum":"  112","line":"  # ```"},
{"lineNum":"  113","line":"  def self.int_to_hex(i : Int)","class":"lineCov","hits":"1","order":"106","possible_hits":"1",},
{"lineNum":"  114","line":"    h = i.to_s 16","class":"lineCov","hits":"1","order":"107","possible_hits":"1",},
{"lineNum":"  115","line":"    return \"0#{h}\" if h.size.odd?","class":"lineCov","hits":"1","order":"108","possible_hits":"1",},
{"lineNum":"  116","line":"    h"},
{"lineNum":"  117","line":"  end"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"  # Converts hex-encoded `String`s to binary `Bytes` data."},
{"lineNum":"  120","line":"  #"},
{"lineNum":"  121","line":"  # Parameters:"},
{"lineNum":"  122","line":"  # * `h` (`String`): the hex-encoded `String` to convert."},
{"lineNum":"  123","line":"  #"},
{"lineNum":"  124","line":"  # ```"},
{"lineNum":"  125","line":"  # Rlp::Util.hex_to_bin \"04c81d\""},
{"lineNum":"  126","line":"  # # => Bytes[4, 200, 29]"},
{"lineNum":"  127","line":"  # ```"},
{"lineNum":"  128","line":"  def self.hex_to_bin(h : String)","class":"lineCov","hits":"2","order":"98","possible_hits":"2",},
{"lineNum":"  129","line":"    h = \"0#{h}\" if h.size.odd?","class":"lineCov","hits":"1","order":"99","possible_hits":"1",},
{"lineNum":"  130","line":"    h.hexbytes","class":"lineCov","hits":"1","order":"100","possible_hits":"1",},
{"lineNum":"  131","line":"  end"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"  # Converts hex-encoded `String`s to `BigInt`s."},
{"lineNum":"  134","line":"  #"},
{"lineNum":"  135","line":"  # Parameters:"},
{"lineNum":"  136","line":"  # * `h` (`String`): the hex-encoded `String` to convert."},
{"lineNum":"  137","line":"  #"},
{"lineNum":"  138","line":"  # ```"},
{"lineNum":"  139","line":"  # Rlp::Util.hex_to_int \"04c81d\""},
{"lineNum":"  140","line":"  # # => 313373"},
{"lineNum":"  141","line":"  # ```"},
{"lineNum":"  142","line":"  def self.hex_to_int(h : String)","class":"lineCov","hits":"2","order":"109","possible_hits":"2",},
{"lineNum":"  143","line":"    h = \"0#{h}\" if h.size.odd?","class":"lineCov","hits":"1","order":"110","possible_hits":"1",},
{"lineNum":"  144","line":"    BigInt.new h, 16","class":"lineCov","hits":"1","order":"111","possible_hits":"1",},
{"lineNum":"  145","line":"  end"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"  # Converts hex-encoded `String`s to `String` literals."},
{"lineNum":"  148","line":"  #"},
{"lineNum":"  149","line":"  # Parameters:"},
{"lineNum":"  150","line":"  # * `h` (`String`): the hex-encoded `String` to convert."},
{"lineNum":"  151","line":"  #"},
{"lineNum":"  152","line":"  # ```"},
{"lineNum":"  153","line":"  # Rlp::Util.hex_to_str \"646f67\""},
{"lineNum":"  154","line":"  # # => \"dog\""},
{"lineNum":"  155","line":"  # ```"},
{"lineNum":"  156","line":"  def self.hex_to_str(h : String)","class":"lineCov","hits":"2","order":"112","possible_hits":"2",},
{"lineNum":"  157","line":"    h = \"0#{h}\" if h.size.odd?","class":"lineCov","hits":"1","order":"113","possible_hits":"1",},
{"lineNum":"  158","line":"    String.new h.hexbytes","class":"lineCov","hits":"1","order":"114","possible_hits":"1",},
{"lineNum":"  159","line":"  end"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"  # Converts `String` literals to binary `Bytes` data."},
{"lineNum":"  162","line":"  #"},
{"lineNum":"  163","line":"  # Parameters:"},
{"lineNum":"  164","line":"  # * `s` (`String`): the `String` literal to convert."},
{"lineNum":"  165","line":"  #"},
{"lineNum":"  166","line":"  # ```"},
{"lineNum":"  167","line":"  # Rlp::Util.str_to_bin \"abc\""},
{"lineNum":"  168","line":"  # # => Bytes[97, 98, 99]"},
{"lineNum":"  169","line":"  # ```"},
{"lineNum":"  170","line":"  def self.str_to_bin(s : String)","class":"lineCov","hits":"1","order":"32","possible_hits":"1",},
{"lineNum":"  171","line":"    s.to_slice","class":"lineCov","hits":"1","order":"33","possible_hits":"1",},
{"lineNum":"  172","line":"  end"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"  # Converts `String` literals to hex-encoded `String`s."},
{"lineNum":"  175","line":"  #"},
{"lineNum":"  176","line":"  # Parameters:"},
{"lineNum":"  177","line":"  # * `s` (`String`): the `String` literal to convert."},
{"lineNum":"  178","line":"  #"},
{"lineNum":"  179","line":"  # ```"},
{"lineNum":"  180","line":"  # Rlp::Util.str_to_hex \"dog\""},
{"lineNum":"  181","line":"  # # => \"646f67\""},
{"lineNum":"  182","line":"  # ```"},
{"lineNum":"  183","line":"  def self.str_to_hex(s : String)","class":"lineCov","hits":"1","order":"115","possible_hits":"1",},
{"lineNum":"  184","line":"    s.to_slice.hexstring","class":"lineCov","hits":"1","order":"116","possible_hits":"1",},
{"lineNum":"  185","line":"  end"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  # Concatenates two `Bytes` slices of `UInt8`."},
{"lineNum":"  188","line":"  #"},
{"lineNum":"  189","line":"  # ```"},
{"lineNum":"  190","line":"  # a = Bytes[131]"},
{"lineNum":"  191","line":"  # b = Bytes[97, 98, 99]"},
{"lineNum":"  192","line":"  # Rlp::Util.binary_add a, b"},
{"lineNum":"  193","line":"  # # => Bytes[131, 97, 98, 99]"},
{"lineNum":"  194","line":"  # ```"},
{"lineNum":"  195","line":"  def self.binary_add(a : Bytes, b : Bytes)","class":"lineCov","hits":"2","order":"23","possible_hits":"2",},
{"lineNum":"  196","line":"    # Concatenate `Bytes` by writing to memory."},
{"lineNum":"  197","line":"    c = IO::Memory.new a.bytesize + b.bytesize","class":"lineCov","hits":"1","order":"24","possible_hits":"1",},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    # Write the `Bytes` from `a`."},
{"lineNum":"  200","line":"    a.each do |v|"},
{"lineNum":"  201","line":"      c.write_bytes UInt8.new v","class":"lineCov","hits":"1","order":"25","possible_hits":"1",},
{"lineNum":"  202","line":"    end"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    # Write the `Bytes` from `b`."},
{"lineNum":"  205","line":"    b.each do |v|"},
{"lineNum":"  206","line":"      c.write_bytes UInt8.new v","class":"lineCov","hits":"1","order":"26","possible_hits":"1",},
{"lineNum":"  207","line":"    end"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    # Return a slice."},
{"lineNum":"  210","line":"    c.to_slice","class":"lineCov","hits":"1","order":"27","possible_hits":"1",},
{"lineNum":"  211","line":"  end"},
{"lineNum":"  212","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "run_coverage", "date" : "2021-09-29 14:56:13", "instrumented" : 33, "covered" : 33,};
var merged_data = [];
