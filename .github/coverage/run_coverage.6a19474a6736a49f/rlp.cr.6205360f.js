var data = {lines:[
{"lineNum":"    1","line":"# Copyright 2020 @q9f"},
{"lineNum":"    2","line":"#"},
{"lineNum":"    3","line":"# Licensed under the Apache License, Version 2.0 (the \"License\");"},
{"lineNum":"    4","line":"# you may not use this file except in compliance with the License."},
{"lineNum":"    5","line":"# You may obtain a copy of the License at"},
{"lineNum":"    6","line":"#"},
{"lineNum":"    7","line":"#     http://www.apache.org/licenses/LICENSE-2.0"},
{"lineNum":"    8","line":"#"},
{"lineNum":"    9","line":"# Unless required by applicable law or agreed to in writing, software"},
{"lineNum":"   10","line":"# distributed under the License is distributed on an \"AS IS\" BASIS,"},
{"lineNum":"   11","line":"# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."},
{"lineNum":"   12","line":"# See the License for the specific language governing permissions and"},
{"lineNum":"   13","line":"# limitations under the License."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"require \"big/big_int\""},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"require \"./array.cr\""},
{"lineNum":"   18","line":"require \"./constants.cr\""},
{"lineNum":"   19","line":"require \"./util.cr\""},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"# The `Rlp` module implementing Ethereum\'s Recursive Length Prefix"},
{"lineNum":"   22","line":"# for arbitrary data encoding and decoding."},
{"lineNum":"   23","line":"module Rlp"},
{"lineNum":"   24","line":"  # RLP-encodes binary `Bytes` data."},
{"lineNum":"   25","line":"  #"},
{"lineNum":"   26","line":"  # Parameters:"},
{"lineNum":"   27","line":"  # * `b` (`Bytes`): the binary `Bytes` data to encode."},
{"lineNum":"   28","line":"  #"},
{"lineNum":"   29","line":"  # ```"},
{"lineNum":"   30","line":"  # Rlp.encode Bytes[15, 66, 64]"},
{"lineNum":"   31","line":"  # # => Bytes[131, 15, 66, 64]"},
{"lineNum":"   32","line":"  # ```"},
{"lineNum":"   33","line":"  def self.encode(b : Bytes)","class":"lineCov","hits":"2","order":"16","possible_hits":"2",},
{"lineNum":"   34","line":"    # If the byte-array contains a single byte solely"},
{"lineNum":"   35","line":"    # and that single byte is less than `128` (`OFFSET_STRING`)"},
{"lineNum":"   36","line":"    # then the input is exactly equal to the output."},
{"lineNum":"   37","line":"    if b.bytesize === 1 && b.first < OFFSET_STRING","class":"lineCov","hits":"2","order":"17","possible_hits":"2",},
{"lineNum":"   38","line":"      return b"},
{"lineNum":"   39","line":"    end"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    # If the byte-array contains fewer than `56` bytes (`LIMIT_SHORT`)"},
{"lineNum":"   42","line":"    # then the output is equal to the input prefixed by the byte"},
{"lineNum":"   43","line":"    # equal to the length of the byte array plus `128` (`OFFSET_STRING`)."},
{"lineNum":"   44","line":"    if b.bytesize < LIMIT_SHORT","class":"lineCov","hits":"1","order":"19","possible_hits":"1",},
{"lineNum":"   45","line":"      # The length of the byte array plus `128` (`OFFSET_STRING`)."},
{"lineNum":"   46","line":"      prefix = UInt8.new b.bytesize + OFFSET_STRING","class":"linePartCov","hits":"1","order":"20","possible_hits":"2",},
{"lineNum":"   47","line":"      p = Bytes[prefix]","class":"lineCov","hits":"1","order":"21","possible_hits":"1",},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"      # Prefixes the data with the prefix byte."},
{"lineNum":"   50","line":"      return Util.binary_add p, b","class":"lineCov","hits":"1","order":"22","possible_hits":"1",},
{"lineNum":"   51","line":"    end"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    # Otherwise, the output is equal to the input prefixed by the"},
{"lineNum":"   54","line":"    # minimal-length byte-array which when interpreted as a big-endian integer"},
{"lineNum":"   55","line":"    # is equal to the length of the input byte array, which is itself prefixed"},
{"lineNum":"   56","line":"    # by the number of bytes required to faithfully encode this length value plus `183`."},
{"lineNum":"   57","line":"    if b.bytesize < LIMIT_LONG","class":"lineCov","hits":"1","order":"37","possible_hits":"1",},
{"lineNum":"   58","line":"      # Gets the size of the data."},
{"lineNum":"   59","line":"      data_size = b.bytesize","class":"lineCov","hits":"1","order":"38","possible_hits":"1",},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"      # Gets the binary representation of the data size."},
{"lineNum":"   62","line":"      header = Util.int_to_bin data_size","class":"lineCov","hits":"1","order":"39","possible_hits":"1",},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"      # Faithfully encodes this length value plus `183`."},
{"lineNum":"   65","line":"      prefix = UInt8.new header.bytesize + OFFSET_STRING + LIMIT_SHORT - 1","class":"linePartCov","hits":"1","order":"40","possible_hits":"2",},
{"lineNum":"   66","line":"      p = Bytes[prefix]","class":"lineCov","hits":"1","order":"41","possible_hits":"1",},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"      # Prefixes the header with the prefix byte."},
{"lineNum":"   69","line":"      header = Util.binary_add p, header","class":"lineCov","hits":"1","order":"42","possible_hits":"1",},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"      # Prefixes the data with the header data."},
{"lineNum":"   72","line":"      Util.binary_add header, b","class":"lineCov","hits":"1","order":"43","possible_hits":"1",},
{"lineNum":"   73","line":"    else"},
{"lineNum":"   74","line":"      raise \"Invalid data provided (size out of range: #{b.bytesize})\"","class":"linePartCov","hits":"1","order":"44","possible_hits":"2",},
{"lineNum":"   75","line":"    end"},
{"lineNum":"   76","line":"  end"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"  # RLP-encodes nested `Array` data."},
{"lineNum":"   79","line":"  #"},
{"lineNum":"   80","line":"  # Parameters:"},
{"lineNum":"   81","line":"  # * `l` (`Array`): the nested `Array` data to encode."},
{"lineNum":"   82","line":"  #"},
{"lineNum":"   83","line":"  # ```"},
{"lineNum":"   84","line":"  # Rlp.encode [[\"\"], [\"\"]]"},
{"lineNum":"   85","line":"  # # => Bytes[196, 193, 128, 193, 128]"},
{"lineNum":"   86","line":"  # ```"},
{"lineNum":"   87","line":"  def self.encode(l : Array)","class":"lineCov","hits":"11","order":"45","possible_hits":"11",},
{"lineNum":"   88","line":"    # Returns an empty array byte if we detect an empty list."},
{"lineNum":"   89","line":"    if l.empty?","class":"lineCov","hits":"13","order":"46","possible_hits":"13",},
{"lineNum":"   90","line":"      return EMPTY_ARRAY"},
{"lineNum":"   91","line":"    end"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    # Concatenates the serializations of each contained item."},
{"lineNum":"   94","line":"    body = Slice(UInt8).empty","class":"linePartCov","hits":"10","order":"47","possible_hits":"11",},
{"lineNum":"   95","line":"    l.each do |a|"},
{"lineNum":"   96","line":"      if body.size === 0","class":"linePartCov","hits":"23","order":"48","possible_hits":"36",},
{"lineNum":"   97","line":"        body = encode a","class":"linePartCov","hits":"12","order":"49","possible_hits":"30",},
{"lineNum":"   98","line":"      else"},
{"lineNum":"   99","line":"        body = Util.binary_add body, encode a","class":"linePartCov","hits":"13","order":"54","possible_hits":"22",},
{"lineNum":"  100","line":"      end"},
{"lineNum":"  101","line":"    end"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    # If the concatenated serializations of each contained item are"},
{"lineNum":"  104","line":"    # less than `56` bytes in length, then the output is equal to"},
{"lineNum":"  105","line":"    # that concatenation prefixed by the byte equal to the length of"},
{"lineNum":"  106","line":"    # this byte array plus `192` (`OFFSET_ARRAY`)."},
{"lineNum":"  107","line":"    if body.bytesize < LIMIT_SHORT","class":"linePartCov","hits":"10","order":"50","possible_hits":"11",},
{"lineNum":"  108","line":"      # The length of this byte array plus `192` (`OFFSET_ARRAY`)."},
{"lineNum":"  109","line":"      prefix = UInt8.new body.bytesize + OFFSET_ARRAY","class":"linePartCov","hits":"8","order":"51","possible_hits":"22",},
{"lineNum":"  110","line":"      p = Bytes[prefix]","class":"linePartCov","hits":"8","order":"52","possible_hits":"11",},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"      # Prefixes the data with the prefix byte."},
{"lineNum":"  113","line":"      return Util.binary_add p, body","class":"linePartCov","hits":"8","order":"53","possible_hits":"11",},
{"lineNum":"  114","line":"    end"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"    # Otherwise, the output is equal to the concatenated serializations"},
{"lineNum":"  117","line":"    # prefixed by the minimal-length byte-array which when interpreted as"},
{"lineNum":"  118","line":"    # a big-endian integer is equal to the length of the concatenated"},
{"lineNum":"  119","line":"    # serializations byte array, which is itself prefixed by the number of bytes"},
{"lineNum":"  120","line":"    # required to faithfully encode this length value plus `247`."},
{"lineNum":"  121","line":"    if body.bytesize < LIMIT_LONG","class":"linePartCov","hits":"3","order":"55","possible_hits":"11",},
{"lineNum":"  122","line":"      # Gets the size of the data."},
{"lineNum":"  123","line":"      data_size = body.bytesize","class":"linePartCov","hits":"3","order":"56","possible_hits":"11",},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"      # Gets the binary representation of the data size."},
{"lineNum":"  126","line":"      header = Util.int_to_bin data_size","class":"linePartCov","hits":"3","order":"57","possible_hits":"11",},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"      # Faithfully encodes this length value plus `247`."},
{"lineNum":"  129","line":"      prefix = UInt8.new header.bytesize + OFFSET_ARRAY + LIMIT_SHORT - 1","class":"linePartCov","hits":"3","order":"58","possible_hits":"22",},
{"lineNum":"  130","line":"      p = Bytes[prefix]","class":"linePartCov","hits":"3","order":"59","possible_hits":"11",},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"      # Prefixes the header with the prefix byte."},
{"lineNum":"  133","line":"      header = Util.binary_add p, header","class":"linePartCov","hits":"3","order":"60","possible_hits":"11",},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"      # Prefixes the data with the header data."},
{"lineNum":"  136","line":"      Util.binary_add header, body","class":"linePartCov","hits":"3","order":"61","possible_hits":"11",},
{"lineNum":"  137","line":"    else"},
{"lineNum":"  138","line":"      raise \"Invalid list provided (size out of range: #{body.bytesize})\"","class":"linePartCov","hits":"3","order":"62","possible_hits":"22",},
{"lineNum":"  139","line":"    end"},
{"lineNum":"  140","line":"  end"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"  # RLP-encodes `String` literals."},
{"lineNum":"  143","line":"  #"},
{"lineNum":"  144","line":"  # Parameters:"},
{"lineNum":"  145","line":"  # * `s` (`String`): the `String` literal to encode."},
{"lineNum":"  146","line":"  #"},
{"lineNum":"  147","line":"  # ```"},
{"lineNum":"  148","line":"  # Rlp.encode \"dog\""},
{"lineNum":"  149","line":"  # # => Bytes[131, 100, 111, 103]"},
{"lineNum":"  150","line":"  # ```"},
{"lineNum":"  151","line":"  def self.encode(s : String)","class":"lineCov","hits":"1","order":"28","possible_hits":"1",},
{"lineNum":"  152","line":"    if s.empty?","class":"lineCov","hits":"1","order":"29","possible_hits":"1",},
{"lineNum":"  153","line":"      # Returns an empty string byte if we detect an empty string"},
{"lineNum":"  154","line":"      EMPTY_STRING"},
{"lineNum":"  155","line":"    elsif s.size < LIMIT_LONG","class":"lineCov","hits":"1","order":"30","possible_hits":"1",},
{"lineNum":"  156","line":"      # A string is simply handled as binary data here."},
{"lineNum":"  157","line":"      encode Util.str_to_bin s","class":"lineCov","hits":"1","order":"31","possible_hits":"1",},
{"lineNum":"  158","line":"    else"},
{"lineNum":"  159","line":"      raise \"Invalid string provided (size out of range: #{s.size})\"","class":"linePartCov","hits":"1","order":"34","possible_hits":"2",},
{"lineNum":"  160","line":"    end"},
{"lineNum":"  161","line":"  end"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  # RLP-encodes scalar `Int` numbers."},
{"lineNum":"  164","line":"  #"},
{"lineNum":"  165","line":"  # Parameters:"},
{"lineNum":"  166","line":"  # * `i` (`Int`): the scalar `Int` number to encode."},
{"lineNum":"  167","line":"  #"},
{"lineNum":"  168","line":"  # ```"},
{"lineNum":"  169","line":"  # Rlp.encode 1_000_000"},
{"lineNum":"  170","line":"  # # => Bytes[131, 15, 66, 64]"},
{"lineNum":"  171","line":"  # ```"},
{"lineNum":"  172","line":"  def self.encode(i : Int)","class":"lineCov","hits":"6","order":"5","possible_hits":"6",},
{"lineNum":"  173","line":"    if i === 0","class":"lineCov","hits":"6","order":"6","possible_hits":"6",},
{"lineNum":"  174","line":"      # The scalar `0` is treated as empty string literal, not as zero byte."},
{"lineNum":"  175","line":"      EMPTY_STRING"},
{"lineNum":"  176","line":"    elsif i > 0 && i < LIMIT_LONG","class":"lineCov","hits":"12","order":"10","possible_hits":"12",},
{"lineNum":"  177","line":"      # If `Rlp` is used to encode a scalar, defined only as a positive integer"},
{"lineNum":"  178","line":"      # it must be specified as the shortest byte array such that the"},
{"lineNum":"  179","line":"      # big-endian interpretation of it is equal."},
{"lineNum":"  180","line":"      encode Util.int_to_bin i","class":"linePartCov","hits":"5","order":"11","possible_hits":"6",},
{"lineNum":"  181","line":"    else"},
{"lineNum":"  182","line":"      raise \"Invalid scalar provided (out of range: #{i})\"","class":"linePartCov","hits":"12","order":"7","possible_hits":"18",},
{"lineNum":"  183","line":"    end"},
{"lineNum":"  184","line":"  end"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"  # RLP-encodes `Char` characters."},
{"lineNum":"  187","line":"  #"},
{"lineNum":"  188","line":"  # Parameters:"},
{"lineNum":"  189","line":"  # * `c` (`Char`): the `Char` character to encode."},
{"lineNum":"  190","line":"  #"},
{"lineNum":"  191","line":"  # ```"},
{"lineNum":"  192","line":"  # Rlp.encode \'x\'"},
{"lineNum":"  193","line":"  # # => Bytes[120]"},
{"lineNum":"  194","line":"  # ```"},
{"lineNum":"  195","line":"  def self.encode(c : Char)","class":"lineCov","hits":"1","order":"35","possible_hits":"1",},
{"lineNum":"  196","line":"    # We simpy treat characters as strings."},
{"lineNum":"  197","line":"    encode c.to_s","class":"lineCov","hits":"1","order":"36","possible_hits":"1",},
{"lineNum":"  198","line":"  end"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"  # RLP-encodes boolean `Bool` values."},
{"lineNum":"  201","line":"  #"},
{"lineNum":"  202","line":"  # Parameters:"},
{"lineNum":"  203","line":"  # * `o` (`Bool`): the boolean `Bool` value to encode."},
{"lineNum":"  204","line":"  #"},
{"lineNum":"  205","line":"  # ```"},
{"lineNum":"  206","line":"  # Rlp.encode true"},
{"lineNum":"  207","line":"  # # => Bytes[1]"},
{"lineNum":"  208","line":"  # ```"},
{"lineNum":"  209","line":"  def self.encode(o : Bool)","class":"lineCov","hits":"1","order":"8","possible_hits":"1",},
{"lineNum":"  210","line":"    if o","class":"lineCov","hits":"1","order":"9","possible_hits":"1",},
{"lineNum":"  211","line":"      # Basically, `true` is `1`."},
{"lineNum":"  212","line":"      Bytes[1]","class":"lineCov","hits":"1","order":"18","possible_hits":"1",},
{"lineNum":"  213","line":"    else"},
{"lineNum":"  214","line":"      # And `false` is `0` which is equal the empty string `\"\"`."},
{"lineNum":"  215","line":"      EMPTY_STRING"},
{"lineNum":"  216","line":"    end"},
{"lineNum":"  217","line":"  end"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"  # Decodes arbitrary data structures from a given binary"},
{"lineNum":"  220","line":"  # recursive length prefix data stream."},
{"lineNum":"  221","line":"  #"},
{"lineNum":"  222","line":"  # Parameters:"},
{"lineNum":"  223","line":"  # * `rlp` (`Bytes`): the encoded `Rlp` data to decode."},
{"lineNum":"  224","line":"  #"},
{"lineNum":"  225","line":"  # ```"},
{"lineNum":"  226","line":"  # Rlp.decode Bytes[195, 193, 192, 192]"},
{"lineNum":"  227","line":"  # # => [[[]], []]"},
{"lineNum":"  228","line":"  # ```"},
{"lineNum":"  229","line":"  #"},
{"lineNum":"  230","line":"  # NOTE: The returned data only restores the data structure."},
{"lineNum":"  231","line":"  # It\'s up to the protocol to determine the meaning of the data"},
{"lineNum":"  232","line":"  # as defined in Ethereum\'s design rationale."},
{"lineNum":"  233","line":"  def self.decode(rlp : Bytes)","class":"lineCov","hits":"2","order":"63","possible_hits":"2",},
{"lineNum":"  234","line":"    # Catches known edgecases and returns early."},
{"lineNum":"  235","line":"    if rlp === EMPTY_STRING","class":"lineCov","hits":"1","order":"64","possible_hits":"1",},
{"lineNum":"  236","line":"      # We return a string here instead of binary because we know for"},
{"lineNum":"  237","line":"      # certain that this value represents an empty string."},
{"lineNum":"  238","line":"      return \"\""},
{"lineNum":"  239","line":"    elsif rlp === EMPTY_ARRAY","class":"lineCov","hits":"1","order":"65","possible_hits":"1",},
{"lineNum":"  240","line":"      # We return an array here instead of binary because we know for"},
{"lineNum":"  241","line":"      # certain that this value represents an empty array."},
{"lineNum":"  242","line":"      return [] of RecursiveArray","class":"lineCov","hits":"1","order":"70","possible_hits":"1",},
{"lineNum":"  243","line":"    end"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    # Firstly, takes a look at the prefix byte."},
{"lineNum":"  246","line":"    prefix = rlp.first","class":"lineCov","hits":"1","order":"66","possible_hits":"1",},
{"lineNum":"  247","line":"    length = rlp.bytesize","class":"lineCov","hits":"1","order":"67","possible_hits":"1",},
{"lineNum":"  248","line":"    if prefix < OFFSET_STRING && length === 1","class":"lineCov","hits":"2","order":"68","possible_hits":"2",},
{"lineNum":"  249","line":"      # If the value is lower than `128`, return the byte directly."},
{"lineNum":"  250","line":"      rlp"},
{"lineNum":"  251","line":"    elsif prefix < OFFSET_STRING + LIMIT_SHORT","class":"linePartCov","hits":"1","order":"71","possible_hits":"2",},
{"lineNum":"  252","line":"      # If it\'s a short string, cut off the prefix and return the string."},
{"lineNum":"  253","line":"      offset = 1","class":"lineCov","hits":"1","order":"72","possible_hits":"1",},
{"lineNum":"  254","line":"      rlp[offset, length - offset]","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  255","line":"    elsif prefix < OFFSET_ARRAY","class":"lineCov","hits":"2","order":"73","possible_hits":"2",},
{"lineNum":"  256","line":"      # If it\'s a long string, cut off the prefix header and return the string."},
{"lineNum":"  257","line":"      offset = 1 + prefix - 183","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  258","line":"      rlp[offset, length - offset]","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  259","line":"    else"},
{"lineNum":"  260","line":"      # If it\'s not a byte or a string, then we have some type of array here."},
{"lineNum":"  261","line":"      result = [] of RecursiveArray","class":"lineCov","hits":"1","order":"74","possible_hits":"1",},
{"lineNum":"  262","line":"      if prefix < OFFSET_ARRAY + LIMIT_SHORT","class":"linePartCov","hits":"1","order":"75","possible_hits":"2",},
{"lineNum":"  263","line":"        # If it\'s a small array, cut off the prefix."},
{"lineNum":"  264","line":"        offset = 1","class":"lineCov","hits":"1","order":"76","possible_hits":"1",},
{"lineNum":"  265","line":"        rlp = rlp[offset, length - offset]","class":"linePartCov","hits":"1","order":"87","possible_hits":"2",},
{"lineNum":"  266","line":"      else"},
{"lineNum":"  267","line":"        # If it\'s a massive array, cut off the prefix and header."},
{"lineNum":"  268","line":"        offset = 1 + prefix - 247","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  269","line":"        rlp = rlp[offset, length - offset]","class":"linePartCov","hits":"1","order":"77","possible_hits":"2",},
{"lineNum":"  270","line":"      end"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"      # Now we recursively decode each item nested in the array."},
{"lineNum":"  273","line":"      while rlp.bytesize > 0","class":"lineCov","hits":"1","order":"78","possible_hits":"1",},
{"lineNum":"  274","line":"        # Getting the prefix of each nested item (if any)."},
{"lineNum":"  275","line":"        prefix = rlp.first","class":"lineCov","hits":"1","order":"79","possible_hits":"1",},
{"lineNum":"  276","line":"        length = 0","class":"lineCov","hits":"1","order":"80","possible_hits":"1",},
{"lineNum":"  277","line":"        if prefix < OFFSET_STRING","class":"lineCov","hits":"1","order":"81","possible_hits":"1",},
{"lineNum":"  278","line":"          # This is a nested byte of length `1`."},
{"lineNum":"  279","line":"          length = 1","class":"lineCov","hits":"1","order":"86","possible_hits":"1",},
{"lineNum":"  280","line":"        elsif prefix < OFFSET_STRING + LIMIT_SHORT","class":"linePartCov","hits":"2","order":"82","possible_hits":"3",},
{"lineNum":"  281","line":"          # This is a nested short string literal."},
{"lineNum":"  282","line":"          length = 1 + prefix - OFFSET_STRING","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  283","line":"        elsif prefix < OFFSET_ARRAY","class":"lineCov","hits":"2","order":"88","possible_hits":"2",},
{"lineNum":"  284","line":"          # This is a nested long string literal."},
{"lineNum":"  285","line":"          header_size = prefix - 183","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  286","line":"          header = rlp[1, header_size]","class":"lineCov","hits":"1","order":"89","possible_hits":"1",},
{"lineNum":"  287","line":"          length = 1 + header_size + Util.bin_to_int header","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  288","line":"        elsif prefix < OFFSET_ARRAY + LIMIT_SHORT","class":"linePartCov","hits":"2","order":"93","possible_hits":"3",},
{"lineNum":"  289","line":"          # This is a nested small array."},
{"lineNum":"  290","line":"          length = 1 + prefix - OFFSET_ARRAY","class":"linePartCov","hits":"1","order":"94","possible_hits":"2",},
{"lineNum":"  291","line":"        else"},
{"lineNum":"  292","line":"          # This is a nested massive array."},
{"lineNum":"  293","line":"          header_size = prefix - 247","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  294","line":"          header = rlp[1, header_size]","class":"lineCov","hits":"1","order":"95","possible_hits":"1",},
{"lineNum":"  295","line":"          length = 1 + header_size + Util.bin_to_int header","class":"linePartCov","hits":"4","order":"83","possible_hits":"5",},
{"lineNum":"  296","line":"        end"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"        # We push the recursively decoded item to the result."},
{"lineNum":"  299","line":"        result << decode rlp[0, length]","class":"lineCov","hits":"1","order":"84","possible_hits":"1",},
{"lineNum":"  300","line":"        offset = length","class":"lineCov","hits":"2","order":"85","possible_hits":"2",},
{"lineNum":"  301","line":"        length = rlp.size - length","class":"lineCov","hits":"2","order":"92","possible_hits":"2",},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"        # And move on with the rest of the data."},
{"lineNum":"  304","line":"        rlp = rlp[offset, length]","class":"lineCov","hits":"5","order":"69","possible_hits":"5",},
{"lineNum":"  305","line":"      end"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"      # Until we decoded all items and return the resulting structure."},
{"lineNum":"  308","line":"      result"},
{"lineNum":"  309","line":"    end"},
{"lineNum":"  310","line":"  end"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"  # Decodes arbitrary data structures from a given hex-encoded"},
{"lineNum":"  313","line":"  # recursive length prefix data stream."},
{"lineNum":"  314","line":"  #"},
{"lineNum":"  315","line":"  # Parameters:"},
{"lineNum":"  316","line":"  # * `hex` (`String`): the encoded `Rlp` data to decode."},
{"lineNum":"  317","line":"  #"},
{"lineNum":"  318","line":"  # ```"},
{"lineNum":"  319","line":"  # Rlp.decode \"c7c0c1c0c3c0c1c0\""},
{"lineNum":"  320","line":"  # # => [[], [[]], [[], [[]]]]"},
{"lineNum":"  321","line":"  # ```"},
{"lineNum":"  322","line":"  #"},
{"lineNum":"  323","line":"  # NOTE: The returned data only restores the data structure."},
{"lineNum":"  324","line":"  # It\'s up to the protocol to determine the meaning of the data"},
{"lineNum":"  325","line":"  # as defined in Ethereum\'s design rationale."},
{"lineNum":"  326","line":"  def self.decode(hex : String)","class":"lineCov","hits":"1","order":"96","possible_hits":"1",},
{"lineNum":"  327","line":"    decode Util.hex_to_bin hex","class":"lineCov","hits":"1","order":"97","possible_hits":"1",},
{"lineNum":"  328","line":"  end"},
{"lineNum":"  329","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "run_coverage", "date" : "2021-09-29 14:56:13", "instrumented" : 88, "covered" : 80,};
var merged_data = [];
